// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: erc20_transfer_operations.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countERC20Transfers = `-- name: CountERC20Transfers :one
SELECT COUNT(*) as count
FROM erc20_transfers
`

func (q *Queries) CountERC20Transfers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countERC20Transfers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createERC20Transfer = `-- name: CreateERC20Transfer :one
INSERT INTO erc20_transfers (tx_hash, log_index, from_address, to_address, value, block_number, token_address)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (tx_hash, log_index) DO UPDATE SET is_canonical = TRUE, reorg_detected_at = NULL
RETURNING tx_hash, log_index, from_address, to_address, value, block_number, token_address
`

type CreateERC20TransferParams struct {
	TxHash       string         `json:"txHash"`
	LogIndex     int32          `json:"logIndex"`
	FromAddress  string         `json:"fromAddress"`
	ToAddress    string         `json:"toAddress"`
	Value        pgtype.Numeric `json:"value"`
	BlockNumber  int64          `json:"blockNumber"`
	TokenAddress string         `json:"tokenAddress"`
}

type CreateERC20TransferRow struct {
	TxHash       string         `json:"txHash"`
	LogIndex     int32          `json:"logIndex"`
	FromAddress  string         `json:"fromAddress"`
	ToAddress    string         `json:"toAddress"`
	Value        pgtype.Numeric `json:"value"`
	BlockNumber  int64          `json:"blockNumber"`
	TokenAddress string         `json:"tokenAddress"`
}

func (q *Queries) CreateERC20Transfer(ctx context.Context, arg CreateERC20TransferParams) (CreateERC20TransferRow, error) {
	row := q.db.QueryRow(ctx, createERC20Transfer,
		arg.TxHash,
		arg.LogIndex,
		arg.FromAddress,
		arg.ToAddress,
		arg.Value,
		arg.BlockNumber,
		arg.TokenAddress,
	)
	var i CreateERC20TransferRow
	err := row.Scan(
		&i.TxHash,
		&i.LogIndex,
		&i.FromAddress,
		&i.ToAddress,
		&i.Value,
		&i.BlockNumber,
		&i.TokenAddress,
	)
	return i, err
}

const deleteERC20TransfersFromHeight = `-- name: DeleteERC20TransfersFromHeight :exec
DELETE FROM erc20_transfers
WHERE block_number > $1
`

func (q *Queries) DeleteERC20TransfersFromHeight(ctx context.Context, blockNumber int64) error {
	_, err := q.db.Exec(ctx, deleteERC20TransfersFromHeight, blockNumber)
	return err
}

const getERC20Transfer = `-- name: GetERC20Transfer :one
SELECT tx_hash, log_index, from_address, to_address, value, block_number, token_address
FROM erc20_transfers
WHERE tx_hash = $1 AND log_index = $2
`

type GetERC20TransferParams struct {
	TxHash   string `json:"txHash"`
	LogIndex int32  `json:"logIndex"`
}

type GetERC20TransferRow struct {
	TxHash       string         `json:"txHash"`
	LogIndex     int32          `json:"logIndex"`
	FromAddress  string         `json:"fromAddress"`
	ToAddress    string         `json:"toAddress"`
	Value        pgtype.Numeric `json:"value"`
	BlockNumber  int64          `json:"blockNumber"`
	TokenAddress string         `json:"tokenAddress"`
}

func (q *Queries) GetERC20Transfer(ctx context.Context, arg GetERC20TransferParams) (GetERC20TransferRow, error) {
	row := q.db.QueryRow(ctx, getERC20Transfer, arg.TxHash, arg.LogIndex)
	var i GetERC20TransferRow
	err := row.Scan(
		&i.TxHash,
		&i.LogIndex,
		&i.FromAddress,
		&i.ToAddress,
		&i.Value,
		&i.BlockNumber,
		&i.TokenAddress,
	)
	return i, err
}

const listERC20TransfersByTxHash = `-- name: ListERC20TransfersByTxHash :many
SELECT tx_hash, log_index, from_address, to_address, value, block_number, token_address
FROM erc20_transfers
WHERE tx_hash = $1
ORDER BY log_index ASC
LIMIT $2 OFFSET $3
`

type ListERC20TransfersByTxHashParams struct {
	TxHash string `json:"txHash"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListERC20TransfersByTxHashRow struct {
	TxHash       string         `json:"txHash"`
	LogIndex     int32          `json:"logIndex"`
	FromAddress  string         `json:"fromAddress"`
	ToAddress    string         `json:"toAddress"`
	Value        pgtype.Numeric `json:"value"`
	BlockNumber  int64          `json:"blockNumber"`
	TokenAddress string         `json:"tokenAddress"`
}

func (q *Queries) ListERC20TransfersByTxHash(ctx context.Context, arg ListERC20TransfersByTxHashParams) ([]ListERC20TransfersByTxHashRow, error) {
	rows, err := q.db.Query(ctx, listERC20TransfersByTxHash, arg.TxHash, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListERC20TransfersByTxHashRow{}
	for rows.Next() {
		var i ListERC20TransfersByTxHashRow
		if err := rows.Scan(
			&i.TxHash,
			&i.LogIndex,
			&i.FromAddress,
			&i.ToAddress,
			&i.Value,
			&i.BlockNumber,
			&i.TokenAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markERC20TransfersReorgedRange = `-- name: MarkERC20TransfersReorgedRange :exec
UPDATE erc20_transfers
SET is_canonical = FALSE, reorg_detected_at = NOW()
WHERE block_number > $1
`

func (q *Queries) MarkERC20TransfersReorgedRange(ctx context.Context, blockNumber int64) error {
	_, err := q.db.Exec(ctx, markERC20TransfersReorgedRange, blockNumber)
	return err
}
